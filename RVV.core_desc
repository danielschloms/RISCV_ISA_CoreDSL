/*

      V
      |
    Zve64d
      |
    Zve64f
   /      \
Zve64x   Zve32f
   \      /
    Zve32x

Sections:
  misa.v bit
  eew in [8,16,32,64]
  vlen >= 128
Configuration-Setting Instructions
Vector Load and Store Instructions
  xlen=32 -> eew != 64
  xlen=64:
Vector Integer Arithmetic Instructions
  zve64* + eew=64 -> NO vmulh.vv, vmulh.vx, vmulhu.vv, vmulhu.vx, vmulhsu.vv, vmulhsu.vx (integer multiply variants that return the high word of the product)
Vector Fixed-point Arithmetic Instructions
  zve64* + eew=64 -> NO vsmul.vv/vsmul.vx
Vector Single-Width Integer Reduction Instructions
Vector Widening Integer Reduction Instructions
Vector Mask Instructions
Vector Permutation Instructions
  zve32x,zve64x -> NO floating-point scalar move instructions
Vector Floating-Point Instructions
  eew=32
  v,zve64d -> eew=64
  v,zve64d -> +widening instructions/conversions(32->64)
Vector Single-Width Floating-Point reduction Instructions
  eew=32
  v,zve64d -> eew=64
  v,zve64d -> +widening reductions(32->64)
*/
/*
*/

import "RVI.core_desc"
import "RISCVBase.core_desc"

InstructionSet RV32V extends RVV {
}

/*InstructionSet RV64V extends RV32V{}*/


InstructionSet RVV extends RVZve64d {
// What missing?
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        // -- Vector Single-Width Floating-Point Reduction Instructions
        // -- Vector Widening Floating-Point Reduction Instructions
        // -- 2 Sort
}

InstructionSet RVZve64d extends RVZve64f {
// + double precision
    // functions {
    //     bool validate_rvv() {
    //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
    //         return extension_enabled("V") && extension_enabled("F") && (_eew == 32 || _eew == 64);
    //     }
    // }
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        //    v,zve64d -> eew=64
        //    v,zve64d -> +widening instructions/conversions(32->64)
        // -- Vector Single-Width Floating-Point Reduction Instructions
        //    v,zve64d -> eew=64
        // -- Vector Widening Floating-Point Reduction Instructions
        //    v,zve64d only
        // -- 2 Sort
}

InstructionSet RVZve64f extends RVZve32f, RVZve64x {
// Ensure?
    // functions {
    //     bool validate_rvv() {
    //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
    //         return extension_enabled("V") && extension_enabled("F") && (_eew == 32);
    //     }
    // }
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        // -- Vector Single-Width Floating-Point Reduction Instructions
        // -- Vector Widening Floating-Point Reduction Instructions
        // -- 2 Sort
}

InstructionSet RVZve32f extends RVZve32x {
// + single precision
    // functions {
    //     bool validate_rvv() {
    //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
    //         return extension_enabled("V") && extension_enabled("F") && _eew == 32;
    //     }
    // }
    // instructions [[enable=validate_rvv()]]{
    instructions {
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- Vector Floating-Point Instructions
        // vfadd.vf?
        // vfadd.vv?
        // vfclass.v?
        // vfcvt.f.x.v?
        // vfcvt.f.xu.v?
        // vfcvt.rtz.x.f.v?
        // vfcvt.rtz.xu.f.v?
        // vfcvt.x.f.v?
        // vfcvt.xu.f.v?
        // vfdiv.vf?
        // vfdiv.vv?
        // vfmadd.vf?
        // vfmadd.vv?
        // vfmax.vf?
        // vfmax.vv?
        // vfmerge.vfm?
        // vfmin.vf?
        // vfmin.vv?
        // vfmsac.vf?
        // vfmsac.vv?
        // vfmsub.vf?
        // vfmsub.vv?
        // vfmul.vf?
        // vfmul.vv?
        // vfncvt.f.f.w?
        // vfncvt.f.x.w?
        // vfncvt.f.xu.w?
        // vfncvt.rod.f.f.w?
        // vfncvt.rtz.x.f.w?
        // vfncvt.rtz.xu.f.w?
        // vfncvt.x.f.w?
        // vfncvt.xu.f.w?
        // vfnmacc.vf?
        // vfnmacc.vv?
        // vfnmadd.vf?
        // vfnmadd.vv?
        // vfnmsac.vf?
        // vfnmsac.vv?
        // vfnmsub.vf?
        // vfnmsub.vv?
        // vfrdiv.vf?
        // vfrec7.v?
        // vfrsub.vf?
        // vfsgnj.vf?
        // vfsgnj.vv?
        // vfsgnjn.vf?
        // vfsgnjn.vv?
        // vfsgnjx.vf?
        // vfsgnjx.vv?
        // vfsqrt7.v?
        // vfsrqt.v?
        // vfsub.vf?
        // vfsub.vv?
        // vfwadd.vf?
        // vfwadd.wv?
        // vfwadd.wf?
        // vfwadd.vv?
        // vfwcvt.f.f.v?
        // vfwcvt.f.x.v?
        // vfwcvt.f.xu.v?
        // vfwcvt.rtz.x.f.v?
        // vfwcvt.rtz.xu.f.v?
        // vfwcvt.x.f.v?
        // vfwcvt.xu.f.v?
        // vfwmacc.vf?
        // vfwmacc.vv?
        // vfwmsac.vf?
        // vfwmsac.vv?
        // vfwmul.vf?
        // vfwmul.vv?
        // vfwnmacc.vf?
        // vfwnmacc.vv?
        // -- Vector Single-Width Floating-Point Reduction Instructions
        // vfredmax.vs?
        // vfredmin.vs?
        // vfredosum.vs?
        // vfredusum.vs?
        // -- Vector Widening Floating-Point Reduction Instructions
        // vfwredosum.vs?
        // vfwredusum.vs?
        // -- 2 Sort
        VFMERGE {
          encoding: 6'b010111 :: 1'b0 :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VFMV_V_F {
          encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
    }
}

InstructionSet RVZve64x extends RVZve32x {
// +eew=64
    instructions {
        // -- Configuration-Setting Instructions
        // -- Vector Load and Store Instructions
        VSOXSEG2EI64_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG3EI64_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG4EI64_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG5EI64_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG6EI64_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG7EI64_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG8EI64_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG2EI64_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG3EI64_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG4EI64_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG5EI64_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG6EI64_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG7EI64_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG8EI64_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG2EI64_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG3EI64_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG4EI64_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG5EI64_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG6EI64_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG7EI64_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG8EI64_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG2EI64_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG3EI64_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG4EI64_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG5EI64_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG6EI64_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG7EI64_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG8EI64_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXEI64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXEI64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXEI64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL1RE64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL2RE64_V {
            encoding: 3'b001 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL4RE64_V {
            encoding: 3'b011 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL8RE64_V {
            encoding: 3'b111 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // Unitstride, 64 bit element
        VLE64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b111);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VLSE64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE64FF_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSSEGE64_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSEGE64_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSSEGE64_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE64_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // Unitstride, 64 bit element
        VSE64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b111);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VSSE64_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Integer Arithmetic Instructions
        // -- Vector Fixed-point Arithmetic Instructions
        // -- Vector Single-Width Integer Reduction Instructions
        // -- Vector Widening Integer Reduction Instructions
        // -- Vector Mask Instructions
        // -- Vector Permutation Instructions
        // -- 2 Sort
    }
}

InstructionSet RVZve32x extends RVVBase {

// No float
// No eew=64
    functions {
        extern unsigned<8> etiss_vload_encoded_unitstride(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<16> pEEW, unsigned<8> pVd, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<64> pMSTART) [[etiss_needs_arch]];
        extern unsigned<8> etiss_vstore_encoded_unitstride(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<16> pEEW, unsigned<8> pVd, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<64> pMSTART) [[etiss_needs_arch]];
        extern unsigned<8> vmv_xs(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pRd, unsigned<8> pVs2, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmv_sx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslideup_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vslideup_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslidedown_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vslidedown_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslide1up_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vslide1down_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        
        // TODO: Divide into sections
        // Zve32x:
        // - EEW 8, 16, 32
        // - Vector configuration instructions

        // 6. Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)
        // In CoreDSL

        // 7. Vector Loads and Stores

        // 11. Vector Integer Arithmetic Instructions
        // 11.1. Vector Single-Width Integer Add and Subtract
        extern unsigned<8> vadd_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vadd_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vadd_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsub_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsub_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vrsub_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vrsub_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);

        // 11.2. Vector Widening Integer Add/Subtract
        // TODO: All tests fail
        extern unsigned<8> vwaddu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwaddu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsubu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsubu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwadd_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwadd_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsub_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsub_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwaddu_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwaddu_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsubu_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsubu_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwadd_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwadd_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vwsub_w_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vwsub_w_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        
        // 11.3. Vector Integer Extension
        // TODO: Missing
        // vzext.vf2
        // vsext.vf2
        // vzext.vf4
        // vsext.vf4
        // vzext.vf8
        // vsext.vf8

        // 11.4. Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions
        // TODO: Implement in softvector
        extern unsigned<8> vadc_vvm(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vadc_vim(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vadc_vxm(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        // vmadc_vvm: _vv version with vm = 0
        // vmadc_vim: _vi version with vm = 0
        // vmadc_vxm: _vx version with vm = 0
        extern unsigned<8> vmadc_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmadc_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmadc_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsbc_vvm(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsbc_vxm(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        // vmsbc_vvm: _vv version with vm = 0
        // vmsbc_vxm: _vx version with vm = 0
        extern unsigned<8> vmsbc_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsbc_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        
        // 11.5. Vector Bitwise Logical Instructions
        extern unsigned<8> vand_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vand_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vand_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vor_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vor_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vor_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vxor_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vxor_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vxor_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);

        // 11.6. Vector Single-Width Shift Instructions
        extern unsigned<8> vsll_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsll_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsll_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsrl_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsrl_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsrl_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vsra_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsra_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vsra_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);

        // 11.7. Vector Narrowing Integer Right Shift Instructions
        // TODO: Missing
        // vnsrl.wv
        // vnsrl.wx
        // vnsrl.wi
        // vnsra.wv
        // vnsra.wx
        // vnsra.wi

        // 11.8. Vector Integer Compare Instructions
        // TODO: All test fail (https://github.com/PhilippvK/riscv-tests (rvv-2024-new): rv32uv tests)
        extern unsigned<8> vmseq_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmseq_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmseq_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsne_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsne_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsne_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsltu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsltu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmslt_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmslt_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsleu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsleu_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsleu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsle_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsle_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsle_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsgtu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsgtu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmsgt_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmsgt_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);

        // 11.9. Vector Integer Min/Max Instructions
        extern unsigned<8> vmin_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmin_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vminu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vminu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmax_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmax_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmaxu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmaxu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);

        // 11.10. Vector Single-Width Integer Multiply Instructions
        extern unsigned<8> vmul_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmul_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        // TODO: Missing
        // vmulh.vv
        // vmulh.vx
        // vmulhu.vv
        // vmulhu.vx
        // vmulhsu.vv
        // vmulhsu.vx

        // 11.11. Vector Integer Divide Instructions
        extern unsigned<8> vdiv_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vdiv_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vdivu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vdivu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vrem_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vrem_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vremu_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vremu_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);   
        
        // 11.12. Vector Widening Integer Multiply Instructions
        // TODO: Missing
        // vwmul.vv
        // vwmul.vx
        // vwmulu.vv
        // vwmulu.vx
        // vwmulsu.vv
        // vwmulsu.vx

        // 11.13. Vector Single-Width Integer Multiply-Add Instructions
        extern unsigned<8> vmacc_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmacc_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vnmsac_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vnmsac_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vmadd_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmadd_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);
        extern unsigned<8> vnmsub_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs1, unsigned<8> pVs2, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vnmsub_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVm, unsigned<8> pVd, unsigned<8> pVs2, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);

        // 11.14. Vector Widening Integer Multiply-Add Instructions
        // TODO: Missing
        // vwmaccu.vv
        // vwmaccu.vx
        // vwmacc.vv
        // vwmacc.vx
        // vwmaccsu.vv
        // vwmaccsu.vx
        // vwmaccus.vx

        // 11.15. Vector Integer Merge Instructions
        // TODO: Missing
        // vmerge.vvm
        // vmerge.vxm
        // vmerge.vim        

        // 11.16. Vector Integer Move Instructions
        extern unsigned<8> vmv_vv(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmv_vi(char* pV, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pVimm, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL);
        extern unsigned<8> vmv_vx(char* pV, char* pR, unsigned<16> pVTYPE, unsigned<8> pVd, unsigned<8> pRs1, unsigned<16> pVSTART, unsigned<16> pVLEN, unsigned<16> pVL, unsigned<8> pXLEN);

        // 16. Vector Permutation Instructions
        // Zve32x, Zve64x: no floating-point operands

        // 16.1. Integer Scalar Move Instructions

        // 16.2. Floating-Point Scalar Move Instructions
        // Not in Zve32x

        // 16.3. Vector Slide Instructions

        // 16.4. Vector Register Gather Instructions

        // 16.5. Vector Compress Instruction

        // 16.6. Whole Vector Register Move

    }
    instructions {
        // -- Configuration-Setting Instructions
        VSETVLI {
            // encoding: 1'b0 :: 1'b0 :: zimm[9:0] :: uimm[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            encoding: 1'b0 :: zimm[10:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(rs1)}, {zimm}";
            behavior: {
                // if(!(CSR[RV_CSR_MSTATUS] & RV_MSTATUS_VS)){
                //     raise(0, 2);  // vpu not enabled
                // }

                unsigned<3> sew[3]  = vtype_extractSEW(zimm);
                unsigned<3> lmul[3] = vtype_extractLMUL(zimm);
                unsigned<1> vta[1]  = vtype_extractTA(zimm);
                unsigned<1> vma[1]  = vtype_extractMA(zimm);

                unsigned<32> _vlmax = 0;
                unsigned<32> _illmask = 0;

                unsigned<32> vlen = CSR[VLENB_ADDR]*8;

                if (lmul & 4){
                    _illmask = (1 << (XLEN-1));
                    if(lmul == 6){
                        _vlmax = vlen / (0x8 << sew) / 4;
                    }else if(lmul == 7){
                        _vlmax = vlen / (0x8 << sew) / 2;
                    }else{
                        _vlmax = vlen / (0x8 << sew) / 8;
                    }
                }else {
                    _illmask = (0 << (XLEN-1));
                    if(lmul == 0){
                        _vlmax = vlen / (0x8 << sew);
                    }else if(lmul == 1){
                        _vlmax = vlen / (0x8 << sew) *2;
                    }else if(lmul == 2){
                        _vlmax = vlen / (0x8 << sew) *4;
                    }else if(lmul == 3){
                        _vlmax = vlen / (0x8 << sew) *8;
                    }
                }
                unsigned<32> _avl = 0;
                if (rs1 != 0){
                    _avl = X[rs1];
                }else if(rd != 0){
                    _avl = ~0;
                }else{
                    _avl = CSR[VL_ADDR];
                }

                unsigned<32> _vl = 0;

                if(_avl <= _vlmax){
                   _vl = _avl;
                }else if(_avl >= (2*_vlmax)){
                   _vl = _vlmax;
                }else{
                   _vl = (_avl % 0x2) ?  _avl/2 + 1 : _avl / 2; // ceil (AVL/2)
                }

                CSR[VL_ADDR] = _vl;
                CSR[VTYPE_ADDR] = _illmask | zimm;
                if(rd != 0) X[rd] = _vl;
                CSR[VSTART_ADDR] = 0;
            }
        }

        VSETIVLI {
            encoding: 1'b1 :: 1'b1 :: zimm[9:0] :: uimm[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(rs1)}, {zimm}";
            behavior: {
                // TODO: Missing
                unsigned<32> _vlmax = 0;
            }
        }

        VSETVL {
            encoding: 1'b1 :: 6'b000000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {

                unsigned<11> zimm[11] = X[rs2];
                unsigned<3> sew[3]  =  vtype_extractSEW(zimm);
                unsigned<3> lmul[3] =  vtype_extractLMUL(zimm);
                unsigned<1> vta[1]  =  vtype_extractTA(zimm);
                unsigned<1> vma[1]  =  vtype_extractMA(zimm);

                unsigned<XLEN> _vlmax = 0;
                unsigned<XLEN> _illmask = 0;

                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                if (lmul & 4){
                    _illmask = (1 << (XLEN-1));
                    if(lmul == 6){
                        _vlmax = _vlen / (0x8 << sew) / 4;
                    }else if(lmul == 7){
                        _vlmax = _vlen / (0x8 << sew) / 2;
                    }else{
                        _vlmax = _vlen / (0x8 << sew) / 8;
                    }
                }else {
                    _illmask = (0 << (XLEN-1));
                    if(lmul == 0){
                        _vlmax = _vlen / (0x8 << sew);
                    }else if(lmul == 1){
                        _vlmax = _vlen / (0x8 << sew) *2;
                    }else if(lmul == 2){
                        _vlmax = _vlen / (0x8 << sew) *4;
                    }else if(lmul == 3){
                        _vlmax = _vlen / (0x8 << sew) *8;
                    }
                }
                unsigned<32> _avl = 0;
                if (rs1 != 0){
                    _avl = X[rs1];
                }else if(rd != 0){
                    _avl = ~0;
                }else{
                    _avl = CSR[VL_ADDR];
                }

                unsigned<32> _vl = 0;

                if(_avl <= _vlmax){
                   _vl = _avl;
                }else if(_avl >= (2*_vlmax)){
                   _vl = _vlmax;
                }else{
                   _vl = (_avl % 0x2) ? _avl/2 +1 : _avl/2; // ceil (AVL/2)
                }

                CSR[VL_ADDR] = _vl;
                CSR[VTYPE_ADDR] = _illmask | zimm;
                if(rd != 0) X[rd] = _vl;
                CSR[VSTART_ADDR] = 0;
            }

        }
        // -- Vector Load and Store Instructions
        // VL1R_V -> VL1RE8_V (pseudo)
        // VL2R_V -> VL2RE8_V (pseudo)
        // VL4R_V -> VL4RE8_V (pseudo)
        // VL8R_V -> VL8RE8_V (pseudo)
        VS1R_V { // TODO: check if eew allowed?
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VS2R_V { // TODO: check if eew allowed?
            encoding: 3'b001 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VS4R_V { // TODO: check if eew allowed?
            encoding: 3'b011 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VS8R_V { // TODO: check if eew allowed?
            encoding: 3'b0111 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG2EI8_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG2EI16_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG2EI32_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG3EI8_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG3EI16_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG3EI32_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG4EI8_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG4EI16_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG4EI32_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG5EI8_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG5EI16_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG5EI32_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG6EI8_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG6EI16_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG6EI32_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG7EI8_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG7EI16_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG7EI32_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG8EI8_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG8EI16_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXSEG8EI32_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG2EI8_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG2EI16_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG2EI32_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG3EI8_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG3EI16_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG3EI32_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG4EI8_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG4EI16_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG4EI32_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG5EI8_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG5EI16_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG5EI32_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG6EI8_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG6EI16_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG6EI32_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG7EI8_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG7EI16_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG7EI32_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG8EI8_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG8EI16_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXSEG8EI32_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG2EI8_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG2EI16_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG2EI32_V {
            encoding: 3'b001 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG3EI8_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG3EI16_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG3EI32_V {
            encoding: 3'b010 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG4EI8_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG4EI16_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG4EI32_V {
            encoding: 3'b011 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG6EI8_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG6EI16_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG6EI32_V {
            encoding: 3'b101 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG5EI8_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG5EI16_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG5EI32_V {
            encoding: 3'b100 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG8EI8_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG8EI16_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG8EI32_V {
            encoding: 3'b111 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG3EI8_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG3EI16_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG3EI32_V {
            encoding: 3'b010 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG2EI8_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG2EI16_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG2EI32_V {
            encoding: 3'b001 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG4EI8_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG4EI16_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG4EI32_V {
            encoding: 3'b011 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG5EI8_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG5EI16_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG5EI32_V {
            encoding: 3'b100 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG6EI8_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG6EI16_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG6EI32_V {
            encoding: 3'b101 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG7EI8_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG7EI16_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXSEG7EI32_V {
            encoding: 3'b110 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG7EI8_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG7EI16_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG7EI32_V {
            encoding: 3'b110 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG8EI8_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG8EI16_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXSEG8EI32_V {
            encoding: 3'b111 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXEI8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXEI16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSOXEI32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXEI8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXEI16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSUXEI32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXEI8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXEI16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLOXEI32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b11 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXEI8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXEI16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLUXEI32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b01 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL1RE8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL2RE8_V {
            encoding: 3'b001 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL4RE8_V {
            encoding: 3'b011 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL8RE8_V {
            encoding: 3'b111 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL1RE16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL2RE16_V {
            encoding: 3'b001 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL4RE16_V {
            encoding: 3'b011 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL8RE16_V {
            encoding: 3'b111 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL1RE32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL2RE32_V {
            encoding: 3'b001 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL4RE32_V {
            encoding: 3'b011 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VL8RE32_V {
            encoding: 3'b111 :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // This conflicts with the FLW/FSW encoding of the RV32F instruction set
        // VLE_U {
        //     encoding: 3'b000 :: mew[0:0] :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: width[2:0] :: vd[4:0] :: 7'b0000111;
        //     assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
        //     behavior: {

        //         unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
        //         unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //         unsigned<XLEN> _vl = CSR[VL_ADDR];
        //         unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

        //         unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
        //         if(ret != 0){
        //             CSR[VSTART_ADDR] = ret >> 8;
        //             raise(0, 2);
        //         } else{
        //             CSR[VSTART_ADDR] = 0;
        //         }
        //     }
        // }
        // Unitstride, 8 bit element
        VLE8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b000);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 16 bit element
        VLE16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b101);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 32 bit element
        VLE32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b110);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vload_encoded_unitstride(V, _vtype, vm, _eew, vd, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); // V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Strided, 8 bit element
        VLSE8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSE16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSE32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE8FF_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE16FF_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLE32FF_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b10000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLM_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b01011 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VLR_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vs3)}, ({name(rs1)})";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSSEGE8_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSSEGE16_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSSEGE32_V {  // nf: 1-7 (nfields: 2-8)
            encoding: nf[2:0] :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE8_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE16_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VLSEGE32_V {  // nf: 1-7 (nfields: 2-8)
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b0000111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSSEGE8_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSSEGE16_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSSEGE32_V {  // nf: 1-7 (nfields: 2-8)
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSEGE8_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSEGE16_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSEGE32_V {  // nf: 1-7 (nfields: 2-8)
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        // This conflicts with the FLW/FSW encoding of the RV32F instruction set
        // VSE_U {
        //     encoding: 3'b000 :: mew[0:0] :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: width[2:0] :: vs3[4:0] :: 7'b0100111;
        //     assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
        //     behavior: {

        //         unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //         unsigned<XLEN> _eew = vcfg_concatEEW(mew, width);
        //         unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //         unsigned<XLEN> _vl = CSR[VL_ADDR];
        //         unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

        //         unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
        //         if(ret != 0){
        //             CSR[VSTART_ADDR] = ret >> 8;
        //             raise(0, 2);
        //         } else{
        //             CSR[VSTART_ADDR] = 0;
        //         }
        //     }
        // }
        // Unitstride, 8 bit element
        VSE8_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b000);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 16 bit element
        VSE16_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b101);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Unitstride, 32 bit element
        VSE32_U {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _eew = vcfg_concatEEW(1'b0, 3'b110);
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = etiss_vstore_encoded_unitstride(V, _vtype, vm, _eew, vs3, _vstart, _vlen, _vl, (unsigned<64>)X[rs1]); //V, MEM[-1],
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Strided, 8 bit element
        VSSE8_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSE16_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSSE32_V {
            encoding: 3'b000 :: 1'b0 :: 2'b10 :: vm[0:0] :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSM_V {
            encoding: 3'b000 :: 1'b0 :: 2'b00 :: vm[0:0] :: 5'b01011 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSR_V {
            encoding: nf[2:0] :: 1'b0 :: 2'b00 :: 1'b1 :: 5'b01000 :: rs1[4:0] :: 3'b000 :: vs3[4:0] :: 7'b0100111;
            assembly:"{name(vs3)}, ({name(rs1)})";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Integer Arithmetic Instructions
        // == Vector Integer Subtract-with-Borrow Instructions
        // Produce difference with borrow
        // funct6=010010
        // vsbc.vvm?
        // funct3=OPIVV
        // vsbc.vxm?
        // funct3=OPIVX
        // Subtract-with-Borrow Instructions
        // Produce borrow out in mask register format
        // funct6=010011
        // vmsbc.vv?
        // funct3=OPIVV
        // vmsbc.vx?
        // funct3=OPIVX
        // vmsbc.vvm??
        // vmsbc.vxm??
        ////
        // == Vector Integer Add-with-Carry
        // Produce sum with carry
        // funct6=010000
        // vadc.vvm?  // vd, vs2, vs1, v0 # Vector-vector // vd[i] = vs2[i] + vs1[i] + v0.mask[i]
        // funct3=OPIVV
        // vadc.vxm?  // vd, vs2, rs1, v0 # Vector-scalar // vd[i] = vs2[i] + x[rs1] + v0.mask[i]
        // funct3=OPIVX
        // vadc.vim?  // vd, vs2, imm, v0 # Vector-immediate // vd[i] = vs2[i] + imm + v0.mask[i]
        // funct3=OPIVI
        // Produce carry out in mask register format
        // funct6=010001
        // vmadc.vvm?  // vd, vs2, vs1, v0 # Vector-vector // vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
        // vmadc.vxm?  // vd, vs2, rs1, v0 # Vector-scalar // vd.mask[i] = carry_out(vs2[i] + x[rs1] + v0.mask[i])
        // vmadc.vim?  // vd, vs2, imm, v0 # Vector-immediate // vd.mask[i] = carry_out(vs2[i] + imm + v0.mask[i])
        // vmadc.vv?  // vd, vs2, vs1 # Vector-vector, no carry-in // vd.mask[i] = carry_out(vs2[i] + vs1[i])
        // funct3=OPIVV
        // vmadc.vx?  // vd, vs2, rs1 # Vector-scalar, no carry-in // vd.mask[i] = carry_out(vs2[i] + x[rs1])
        // funct3=OPIVX
        // vmadc.vi?  // vd, vs2, imm # Vector-immediate, no carry-in // vd.mask[i] = carry_out(vs2[i] + imm)
        // funct3=OPIVI
        ////
        // == Vector Integer Divide Instructions
        // Signed divide
        // funct6=100001
        // vdiv.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPMVV
        // vdiv.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPMVX
        // Unsigned divide
        // funct6=100000
        // vdivu.vv?  // vd, vs2, vs1, vm # Vector-vector
        // vdivu.vx?  // vd, vs2, rs1, vm # vector-scalar
        // Signed remainder
        // funct6=100011
        // vrem.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPMVV
        // vrem.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPMVX
        // Unsigned remainder
        // funct6=100010
        // vremu.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPMVV
        // vremu.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPMVX
        ////
        // == Vector Single-Width Integer Multiply-Add Instructions
        // Integer multiply-add, overwrite addend
        // funct6=101101
        // vmacc.vv?  // vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
        // funct3=OPMVV
        // vmacc.vx?  // vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i]
        // funct3=OPMVX
        // Integer multiply-sub, overwrite minuend
        // funct6=101111
        // vnmsac.vv?  // vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
        // funct3=OPMVV
        // vnmsac.vx?  // vd, rs1, vs2, vm # vd[i] = -(x[rs1] * vs2[i]) + vd[i]
        // funct3=OPMVX
        // Integer multiply-add, overwrite multiplicand
        // funct6=101001
        // vmadd.vv?  // vd, vs1, vs2, vm # vd[i] = (vs1[i] * vd[i]) + vs2[i]
        // vmadd.vx?  // vd, rs1, vs2, vm # vd[i] = (x[rs1] * vd[i]) + vs2[i]
        // Integer multiply-sub, overwrite multiplicand
        // funct6=101011
        // vnmsub.vv?  // vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) + vs2[i]
        // funct3=OPMVV
        // vnmsub.vx?  // vd, rs1, vs2, vm # vd[i] = -(x[rs1] * vd[i]) + vs2[i]
        // funct3=OPMVX
        ////
        // == Vector Integer Min/Max Instructions
        // Unsigned minimum
        // funct6=000100
        // vminu.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPIVV
        // vminu.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPIVX
        // Signed minimum
        // funct6=000101
        // vmin.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPIVV
        // vmin.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPIVX
        // Unsigned maximum
        // funct6=000110
        // vmaxu.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPIVV
        // vmaxu.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPIVX
        // Signed maximum
        // funct6=000111
        // vmax.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPIVV
        // vmax.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPIVX
        ////
        // == Vector Integer Merge Instructions
        // funct6=010111
        // vmerge.vvm?  // vd, vs2, vs1, v0 # vd[i] = v0.mask[i] ? vs1[i] : vs2[i]
        // funct3=OPIVV
        // vmerge.vxm?  // vd, vs2, rs1, v0 # vd[i] = v0.mask[i] ? x[rs1] : vs2[i]
        // funct3=OPIVX
        // vmerge.vim?  // vd, vs2, imm, v0 # vd[i] = v0.mask[i] ? imm : vs2[i]
        // funct3=OPIVI
        ////
        // == Vector Single-Width Integer Multiply Instructions
        // Signed multiply, returning low bits of product
        VMUL_VV {
            // vector-vector
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmul_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMUL_VX {
            // vector-scalar
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmul_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // 11.11. Vector Integer Divide Instructions
        VDIV_VV {
            // vector-vector
            encoding: 6'b100001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vdiv_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VDIV_VX {
            // vector-scalar
            encoding: 6'b100001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vdiv_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VDIVU_VV {
            // vector-vector
            encoding: 6'b100000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vdivu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VDIVU_VX {
            // vector-scalar
            encoding: 6'b100000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vdivu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VREM_VV {
            // vector-vector
            encoding: 6'b100011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vrem_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VREM_VX {
            // vector-scalar
            encoding: 6'b100011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vrem_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VREMU_VV {
            // vector-vector
            encoding: 6'b100010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vremu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VREMU_VX {
            // vector-scalar
            encoding: 6'b100010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vremu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // End 11.11.

        // 11.12. Vector Widening Integer Multiply Instructions

        // End 11.12.

        // 11.13. Vector Single-Width Integer Multiply-Add Instructions
        VMACC_VV {
            // Vector-vector
            encoding: 6'b101101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmacc_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMACC_VX {
            // Vector-scalar
            encoding: 6'b101101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vmacc_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VNMSAC_VV {
            // Vector-vector
            encoding: 6'b101111 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vnmsac_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VNMSAC_VX {
            // Vector-scalar
            encoding: 6'b101111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vnmsac_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VMADD_VV {
            // Vector-vector
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmadd_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMADD_VX {
            // Vector-scalar
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vmadd_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VNMSUB_VV {
            // Vector-vector
            encoding: 6'b101011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vnmsub_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VNMSUB_VX {
            // Vector-scalar
            encoding: 6'b101011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vnmsub_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }
        // End 11.13.

        VMAX_VV {
            // Vector-vector
            encoding: 6'b000111 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmax_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMAX_VX {
            // Vector-scalar
            encoding: 6'b000111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vmax_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VMAXU_VV {
            // Vector-vector
            encoding: 6'b000110 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmaxu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMAXU_VX {
            // Vector-scalar
            encoding: 6'b000110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vmaxu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VMIN_VV {
            // Vector-vector
            encoding: 6'b000101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmin_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMIN_VX {
            // Vector-scalar
            encoding: 6'b000101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vmin_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VMINU_VV {
            // Vector-vector
            encoding: 6'b000100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vminu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMINU_VX {
            // Vector-scalar
            encoding: 6'b000100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vminu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        // 11.4 Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions
        //
        // V-Spec: vadc and vsbc add or subtract the source operands and the carry-in or borrow-in, 
        // and write the result to vector register vd. 
        // These instructions are encoded as masked instructions (vm=0), 
        // but they operate on and write back all body elements. 
        // Encodings corresponding to the unmasked versions (vm=1) are reserved. 
        //
        // Produce sum with carry, funct6 = 010000
        // vadc.vvm   vd, vs2, vs1, v0  # Vector-vector
        // vadc.vxm   vd, vs2, rs1, v0  # Vector-scalar
        // vadc.vim   vd, vs2, imm, v0  # Vector-immediate
        //
        // Produce carry out in mask register format, funct6 = 010001
        // vmadc.vvm   vd, vs2, vs1, v0  # Vector-vector
        // vmadc.vxm   vd, vs2, rs1, v0  # Vector-scalar
        // vmadc.vim   vd, vs2, imm, v0  # Vector-immediate
        // vmadc.vv    vd, vs2, vs1      # Vector-vector, no carry-in
        // vmadc.vx    vd, vs2, rs1      # Vector-scalar, no carry-in
        // vmadc.vi    vd, vs2, imm      # Vector-immediate, no carry-in

        VADC_VVM {
            encoding: 6'b010000 :: 1'b0 :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadc_vvm(V, _vtype, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VADC_VXM {
            encoding: 6'b010000 :: 1'b0 :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadc_vxm(V, X, _vtype, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VADC_VIM {
            encoding: 6'b010000 :: 1'b0 :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(simm5)}}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadc_vim(V, _vtype, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VMADC_VV {
            encoding: 6'b010001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmadc_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMADC_VX {
            encoding: 6'b010001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmadc_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMADC_VI {
            encoding: 6'b010001 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmadc_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // Produce difference with borrow, funct6 = 010010
        // vsbc.vvm   vd, vs2, vs1, v0  # Vector-vector
        // vsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar
        //
        // Produce borrow out in mask register format, funct6 = 010011
        // vmsbc.vvm   vd, vs2, vs1, v0  # Vector-vector
        // vmsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar
        // vmsbc.vv    vd, vs2, vs1      # Vector-vector, no borrow-in
        // vmsbc.vx    vd, vs2, rs1      # Vector-scalar, no borrow-in
        
        VSBC_VVM {
            encoding: 6'b010010 :: 1'b0 :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsbc_vvm(V, _vtype, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSBC_VXM {
            encoding: 6'b010010 :: 1'b0 :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsbc_vxm(V, X, _vtype, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        VMSBC_VV {
            encoding: 6'b010011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsbc_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VMSBC_VX {
            encoding: 6'b010011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsbc_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        
        // End 11.4 Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions


        // Signed multiply, returning high bits of product
        // funct6=100111
        // vmulh.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPMVV
        // vmulh.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPMVX
        // Unsigned multiply, returning high bits of product
        // funct6=100100
        // vmulhu.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPMVV
        // vmulhu.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPMVX
        // Signed(vs2)-Unsigned multiply, returning high bits of product
        // funct6=100110
        // vmulhsu.vv?  // vd, vs2, vs1, vm # Vector-vector
        // funct3=OPMVV
        // vmulhsu.vx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPMVX
        ////
        // Vector Narrowing Integer Right Shift Instructions
        // Narrowing shift right logical, SEW = (2*SEW) >> SEW
        // funct6=101100
        // vnsrl.wv?  // vd, vs2, vs1, vm # vector-vector
        // funct3=OPIVV
        // vnsrl.wx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPIVX
        // vnsrl.wi?  // vd, vs2, uimm, vm # vector-immediate
        // funct3=OPIVI
        // Narrowing shift right arithmetic, SEW = (2*SEW) >> SEW
        // funct6=101101
        // vnsra.wv?  // vd, vs2, vs1, vm # vector-vector
        // funct3=OPIVV
        // vnsra.wx?  // vd, vs2, rs1, vm # vector-scalar
        // funct3=OPIVX
        // vnsra.wi?  // vd, vs2, uimm, vm # vector-immediate
        // funct3=OPIVI
        ////

        // 11.1. Vector Single-Width Integer Add and Subtract
        // Integer adds
        VADD_VV {
            // Vector-vector
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadd_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VADD_VX {
            // vector-scalar
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadd_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VADD_VI {
            // vector-immediate
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}, {imm}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vadd_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // Integer subtract
        VSUB_VV {
            // Vector-vector
            encoding: 6'b000010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsub_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSUB_VX {
            // Vector-scalar
            encoding: 6'b000010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vsub_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VRSUB_VX {
            // Vector-scalar
            encoding: 6'b000011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

               unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
               unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
               unsigned<XLEN> _vl = CSR[VL_ADDR];
               unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

               unsigned<XLEN> ret = vrsub_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
               if(ret != 0){
                   CSR[VSTART_ADDR] = ret >> 8;
                   raise(0, 2);
               } else{
                   CSR[VSTART_ADDR] = 0;
               }
           }
        }

        VRSUB_VI {
            // vector-immediate
            encoding: 6'b000011 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {imm}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vrsub_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // End 11.1.

        // Integer reverse subtract
        // funct6=000011
        // vrsub.vi?
        // funct3=OPIVX
        // vrsub.vx?
        // funct3=OPIVI
        ////
        // Vector Integer Extension
        VZEXT_VF2 {
            // Zero-extend SEW/2 source to SEW destination
            encoding: 6'b010010 :: vm[0:0] :: vs2[4:0] :: 5'b00110 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSEXT_VF2 {
            // Sign-extend SEW/2 source to SEW destination
            encoding: 6'b010010 :: vm[0:0] :: vs2[4:0] :: 5'b00111 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VZEXT_VF4 {
            // Zero-extend SEW/4 source to SEW destination
            encoding: 6'b010010 :: vm[0:0] :: vs2[4:0] :: 5'b00100 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSEXT_VF4 {
            // Sign-extend SEW/4 source to SEW destination
            encoding: 6'b010010 :: vm[0:0] :: vs2[4:0] :: 5'b00101 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VZEXT_VF8 {
            // Zero-extend SEW/8 source to SEW destination
            encoding: 6'b010010 :: vm[0:0] :: vs2[4:0] :: 5'b00100 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VSEXT_VF8 {
            // Sign-extend SEW/8 source to SEW destination
            encoding: 6'b010010 :: vm[0:0] :: vs2[4:0] :: 5'b00011 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        ////
        // == Vector Widening Integer Add/Subtract
        // Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW
        VWADDU_VV {
            // vector-vector
            encoding: 6'b110000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADDU_VX {
            // vector-scalar
            encoding: 6'b110000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VWSUBU_VV {
            // vector-vector
            encoding: 6'b110010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUBU_VX {
            // vector-scalar
            encoding: 6'b110010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Widening signed integer add/subtract, 2*SEW = SEW +/- SEW
        VWADD_VV {
            // vector-vector
            encoding: 6'b110001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADD_VX {
            // vector-scalar
            encoding: 6'b110001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_VV {
            // vector-vector
            encoding: 6'b110011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_VX {
            // vector-scalar
            encoding: 6'b110011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // Widening unsigned integer add/subtract, 2*SEW = 2*SEW +/- SEW
        // funct6=110100
        // vwaddu.wv?
        // vwaddu.wx?
        // Widening signed integer add/subtract, 2*SEW = 2*SEW +/- SEW
        // funct6=110101
        // vwadd.wv?
        // vwadd.wx?
        ////
        // == Vector Widening Integer Multiply-Add Instructions
        // Widening unsigned-integer multiply-add, overwrite addend
        // funct6=111100
        // vwmaccu.vv?  // vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
        // funct3=OPMVV
        // vwmaccu.vx?  // vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i]
        // funct3=OPMVX
        // Widening signed-integer multiply-add, overwrite addend
        /*
        VWMACC_VV {
            encoding: 6'b111101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWMACC_VX {
            encoding: 6'b111101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }*/
        // Widening signed-unsigned-integer multiply-add, overwrite addend
        // funct6=111111
        // vwmaccsu.vv?  // vd, vs1, vs2, vm # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i])) + vd[i]
        // funct3=OPMVV
        // vwmaccsu.vx?  // vd, rs1, vs2, vm # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i])) + vd[i]
        // funct3=OPMVX
        // Widening unsigned-signed-integer multiply-add, overwrite addend
        // funct6=111110
        // vwmaccus.vx  // vd, rs1, vs2, vm # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i])) + vd[i]
        // funct3=OPMVX
        ////
        // == Vector Widening Integer Multiply Instructions
        // Widening signed-integer multiply
        VWMUL_VV {
            encoding: 6'b111011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWMUL_VX {
            encoding: 6'b111011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // Widening unsigned-integer multiply
        // vwmulu.vv?
        // vwmulu.vx
        // Widening signed(vs2)-unsigned integer multiply
        // vwmulsu.vv?
        // vwmulsu.vx?
        ////
        VWMACC_VV {
            encoding: 6'b111101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWMACC_VX {
            encoding: 6'b111101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VWADDU_W_VV {
            encoding: 6'b110100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADDU_W_VX {
            encoding: 6'b110100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwaddu_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADD_W_VV {
            encoding: 6'b110101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWADD_W_VX {
            encoding: 6'b110101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwadd_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUBU_W_VV {
            encoding: 6'b110110 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUBU_W_VX {
            encoding: 6'b110110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsubu_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_W_VV {
            encoding: 6'b110111 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_w_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VWSUB_W_VX {
            encoding: 6'b110111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vwsub_w_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VAND_VV {
            encoding: 6'b001001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vand_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VAND_VI {
            encoding: 6'b001001 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vand_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VAND_VX {
            encoding: 6'b001001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vand_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VOR_VV {
            encoding: 6'b001010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vor_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VOR_VI {
            encoding: 6'b001010 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vor_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VOR_VX {
            encoding: 6'b001010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vor_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VXOR_VV {
            encoding: 6'b001011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vxor_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VXOR_VI {
            encoding: 6'b001011 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vxor_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VXOR_VX {
            encoding: 6'b001011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vxor_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLL_VV {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsll_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLL_VI {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsll_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLL_VX {
            encoding: 6'b100101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsll_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRL_VV {
            encoding: 6'b101000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsrl_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRL_VI {
            encoding: 6'b101000 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsrl_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRL_VX {
            encoding: 6'b101000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsrl_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRA_VV {
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsra_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRA_VI {
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsra_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSRA_VX {
            encoding: 6'b101001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vsra_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        ////
        // == Vector Integer Compare Instructions
        // Set if equal
        VMSEQ_VV {
            encoding: 6'b011000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmseq_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSEQ_VX {
            encoding: 6'b011000 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmseq_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSEQ_VI {
            encoding: 6'b011000 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmseq_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Set if not equal
        VMSNE_VV {
            encoding: 6'b011001 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsne_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSNE_VX {
            encoding: 6'b011001 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsne_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSNE_VI {
            encoding: 6'b011001 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsne_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Set if less than, unsigned
        VMSLTU_VV {
            encoding: 6'b011010 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsltu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSLTU_VX {
            encoding: 6'b011010 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsltu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Set if less than, signed
        VMSLT_VV {
            encoding: 6'b011011 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmslt_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSLT_VX {
            encoding: 6'b011011 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmslt_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Set if less than or equal, unsigned
        VMSLEU_VV {
            encoding: 6'b011100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsleu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSLEU_VX {
            encoding: 6'b011100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsleu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSLEU_VI {
            encoding: 6'b011100 :: vm[0:0] :: vs2[4:0] :: uimm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(uimm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsleu_vi(V, _vtype, vm, vd, vs2, uimm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        // Set if less than or equal, signed
        VMSLE_VV {
            encoding: 6'b011101 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsle_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSLE_VX {
            encoding: 6'b011101 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsle_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSLE_VI {
            encoding: 6'b011101 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsle_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // No need to implement pseudoinstructions?
        // VMSGTU_VV {
        //    encoding: 6'b011110 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
        //    assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
        //    behavior: {
        //
        //        unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //        unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //        unsigned<XLEN> _vl = CSR[VL_ADDR];
        //        unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;
        //
        //        unsigned<XLEN> ret = vmsgtu_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
        //        if(ret != 0){
        //            CSR[VSTART_ADDR] = ret >> 8;
        //            raise(0, 2);
        //        } else{
        //            CSR[VSTART_ADDR] = 0;
        //        }
        //    }
        // }

        // Set if greater than, unsigned
        VMSGTU_VX {
            encoding: 6'b011110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsgtu_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMSGTU_VI {
            encoding: 6'b011110 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        // No need to implement pseudoinstructions?
        // VMSGT_VV {
        //     encoding: 6'b011111 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
        //     assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
        //     behavior: {
        //
        //         unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
        //         unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
        //         unsigned<XLEN> _vl = CSR[VL_ADDR];
        //         unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;
        //
        //         unsigned<XLEN> ret = vmsgt_vv(V, _vtype, vm, vd, vs1, vs2, _vstart, _vlen, _vl);
        //         if(ret != 0){
        //             CSR[VSTART_ADDR] = ret >> 8;
        //             raise(0, 2);
        //         } else{
        //             CSR[VSTART_ADDR] = 0;
        //         }
        //     }
        // }

        // Set if greater than, signed
        VMSGT_VX {
            encoding: 6'b011111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmsgt_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        ////
        // == Vector Integer Move Instructions
        VMV_V_V {
            // vd[i] = vs1[i]
            encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_vv(V, _vtype, vd, vs1, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMV_V_X {
            // vd[i] = x[rs1]
            encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_vx(V, X, _vtype, vd, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VMV_V_I {
            // vd[i] = imm
            encoding: 6'b010111 :: 1'b1 :: 5'b00000 :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(simm5)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_vi(V, _vtype, vd, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        ////


        // -- Vector Fixed-point Arithmetic Instructions
        // vaadd.vv?
        // vaadd.vx?
        // vaaddu.vv?
        // vaaddu.vx?
        // vasub.vv?
        // vasub.vx?
        // vasubu.vv?
        // vasubu.vx?
        // vnclip.wi?
        // vnclip.wv?
        // vnclip.wx?
        // vnclipu.wi?
        // vnclipu.wv?
        // vnclipu.wx?
        // vsadd.vi?
        // vsadd.vv?
        // vsadd.vx?
        // vsaddu.vi?
        // vsaddu.vv?
        // vsaddu.vx?
        // vsmul.vv?
        // vsmul.vx?
        // vssra.vi?
        // vssra.vv?
        // vssra.vx?
        // vssrl.vi?
        // vssrl.vv?
        // vssrl.vx?
        // vssub.vv?
        // vssub.vx?
        // vssubu.vv?
        // vssubu.vx?
        // -- Vector Single-Width Integer Reduction Instructions
        // vredand.vs?
        // vredmax.vs?
        // vredmaxu.vs?
        // vredmin.vs?
        // vredminu.vs?
        // vredor.vs?
        // vredxor.vs?
        VREDSUM_VS {
            encoding: 6'b000000 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(vs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Widening Integer Reduction Instructions
        // vwredsum.vs?
        // vwredsumu.vs?
        // -- Vector Mask Instructions
        // vcpop.m?
        // vfirst.m?
        // viota.m?
        // vmand.mm?
        // vmandn.mm?
        // vmclr.m?
        // vmmv.m?
        // vmnand.mm?
        // vmnor.mm?
        // vmnot.m?
        // vmor.mm?
        // vmorn.mm?
        // vmset.m?
        // vmsif.m?
        // vmsof.m?
        // vmxnor.mm?
        // vmxor.mm?
        VID_V {
            encoding: 6'b010100 :: 1'b1 :: vs2[4:0] :: vs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(vs2)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        // -- Vector Permutation Instructions
        // vmcompress.vm?
        // vfmv.f.s?
        // vfmv.s.f?
        // vmv.x.s?
        // vrgatherei16.vv?
        VMVR_V {
            encoding: 6'b100111 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VRGATHER_VV {
            encoding: 6'b001100 :: vm[0:0] :: vs2[4:0] :: vs1[4:0] :: 3'b000 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VRGATHER_VI {
            encoding: 6'b001100 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }

        VRGATHER_VX {
            encoding: 6'b001100 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}, {name(vm)}";
            behavior: {
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
            }
        }
        VMV_X_S {
            encoding: 6'b010000 :: 1'b1 :: vs2[4:0] :: 5'b00000 :: 3'b010 :: rd[4:0] :: 7'b1010111;
            assembly:"{name(rd)}, {name(vs2)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                //unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                if(rd != 0){
                    unsigned<XLEN> ret = vmv_xs(V, X, _vtype, rd, vs2, _vlen, _vl, XLEN);
                    if(ret != 0){
                        CSR[VSTART_ADDR] = ret >> 8;
                        raise(0, 2);
                    } else{
                        CSR[VSTART_ADDR] = 0;
                    }
                }
            }
        }
        VMV_S_X {
            encoding: 6'b010000 :: 1'b1 :: 5'b00000 :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(rs1)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vmv_sx(V, X, _vtype, vd, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
        VSLIDEUP_VI {
            encoding: 6'b001110 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslideup_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDEUP_VX {
            encoding: 6'b001110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslideup_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        // TODO: vfslide1up vrgatherei16

        VSLIDEDOWN_VI {
            encoding: 6'b001111 :: vm[0:0] :: vs2[4:0] :: simm5[4:0] :: 3'b011 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(simm5)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslidedown_vi(V, _vtype, vm, vd, vs2, simm5, _vstart, _vlen, _vl);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDEDOWN_VX {
            encoding: 6'b001111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b100 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslidedown_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDE1UP_VX {
            encoding: 6'b001110 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslide1up_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }

        VSLIDE1DOWN_VX {
            encoding: 6'b001111 :: vm[0:0] :: vs2[4:0] :: rs1[4:0] :: 3'b110 :: vd[4:0] :: 7'b1010111;
            assembly:"{name(vd)}, {name(vs2)}, {name(rs1)}, {name(vm)}";
            behavior: {

                unsigned<XLEN> _vtype = CSR[VTYPE_ADDR];
                unsigned<XLEN> _vstart = CSR[VSTART_ADDR];
                unsigned<XLEN> _vl = CSR[VL_ADDR];
                unsigned<XLEN> _vlen = CSR[VLENB_ADDR]*8;

                unsigned<XLEN> ret = vslide1down_vx(V, X, _vtype, vm, vd, vs2, rs1, _vstart, _vlen, _vl, XLEN);
                if(ret != 0){
                    CSR[VSTART_ADDR] = ret >> 8;
                    raise(0, 2);
                } else{
                    CSR[VSTART_ADDR] = 0;
                }
            }
        }
    }
}


InstructionSet RVVBase extends Zicsr {

    architectural_state {
        unsigned<32> VLEN;
        // user-writeable
        unsigned<32> VSTART_ADDR = 0x008;
        unsigned<32>& VSTART_CSR = CSR[VSTART_ADDR];
        unsigned<32> VXSAT_ADDR = 0x009;
        unsigned<32>& VXSAT_CSR = CSR[VXSAT_ADDR];
        unsigned<32> VXRM_ADDR = 0x00A;
        unsigned<32>& VXRM_CSR = CSR[VXRM_ADDR];
        unsigned<32> VCSR_ADDR = 0x00F;
        unsigned<32>& VCSR_CSR = CSR[VCSR_ADDR];

        // not user-writable
        unsigned<32> VL_ADDR = 0xC20;
        unsigned<32>& VL_CSR = CSR[VL_ADDR];
        unsigned<32> VTYPE_ADDR = 0xC21;
        unsigned<32>& VTYPE_CSR = CSR[VTYPE_ADDR];

        // read-only constant csr
        unsigned<32> VLENB_ADDR = 0xC22;
        unsigned<32>& VLENB_CSR = CSR[VLENB_ADDR];

        // vector register address space
        extern unsigned char V[VLEN /8 * 32];
    }
    functions {
        extern unsigned<8> vtype_extractSEW(unsigned<16>);
        extern unsigned<8> vtype_extractLMUL(unsigned<16>);
        extern unsigned<8> vtype_extractTA(unsigned<16>);
        extern unsigned<8> vtype_extractMA(unsigned<16>);
        extern unsigned<16> vcfg_concatEEW(unsigned<8> mew, unsigned<8> width);
        // bool check_eew() {
        //     return true;
        // }
    }
}
